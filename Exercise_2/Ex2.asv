%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                Post-graduate Student                       %
%                Emmanouil Thomas Chatzakis                  %
%                2021030061                                  %
%                                                            %
%               Wireless Communications                      %
%                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all,
close all,
clc;
% Parameters
N = 200; % Number of symbols
M = 4; % 4-QAM
SNR_dB = 10; % Example SNR value in dB

%%1
% Channel coefficients for block fading, CN(0,1)
h1 = (randn + 1j*randn)/sqrt(2); 
h2 = (randn + 1j*randn)/sqrt(2);
%%2
% Generate 4-QAM symbols (±1±j, equally likely)
qam_symmbols = [1+1j, 1-1j, -1+1j, -1-1j];
s = qam_symmbols(randi([1 M], N, 1));

%%3
% Signal power for normalization
signal_power = mean(abs(s).^2);

% Calculate noise variance from SNR
SNR_linear = 10^(SNR_dB/10);
N0 = signal_power / SNR_linear;

% Generate AWGN noise for both receivers
n1 = sqrt(N0/2) * (randn(N,1) + 1j*randn(N,1));
n2 = sqrt(N0/2) * (randn(N,1) + 1j*randn(N,1));

% Received signals
r1 = h1 * s + n1;
r2 = h2 * s + n2;

%%4
r_total = conj(h1)*r1 + conj(h2)*r2;       % Combined received signal

norm_h = abs(h1)^2 + abs(h2)^2;           % Channel power normalization

R = r_total / sqrt(norm_h);                  % Normalized combined received signal

% 5. Symbol decisions based on 4-QAM constellation
% Decide on real and imaginary parts separately using sign
s_hat = sign(real(R)) + 1i * sign(imag(R));
 

%%6
qam_symbols = [1+1j, 1-1j, -1+1j, -1-1j];
SNR_dB = 0:2:20; % SNR values in dB
BER = zeros(size(SNR_dB));  % BER results

for idx = 1:length(SNR_dB)
    total_bit_errors = 0;
    total_bits = 0;
    for k = 1:K
        % Channel coefficients for block fading, CN(0,1)
        h1 = (randn + 1j*randn)/sqrt(2);
        h2 = (randn + 1j*randn)/sqrt(2);
        % Generate random symbols
        s_idx = randi([1 M], N, 1);
        s = qam_symbols(s_idx);
        signal_power = mean(abs(s).^2);
        N0 = signal_power / SNR_linear;
        n1 = sqrt(N0/2) * (randn(N,1) + 1j*randn(N,1));
        n2 = sqrt(N0/2) * (randn(N,1) + 1j*randn(N,1));
        r1 = h1 * s + n1;
        r2 = h2 * s + n2;
        r_total = conj(h1)*r1 + conj(h2)*r2;
        norm_h = abs(h1)^2 + abs(h2)^2;
        R = r_total / sqrt(norm_h);
        % Symbol decisions
        s_hat = sign(real(R)) + 1i * sign(imag(R));
        % Map detected symbols back to indices
        s_hat_idx = zeros(N,1);
        for i = 1:M
            s_hat_idx(abs(s_hat - qam_symbols(i)) < 1e-6) = i;
        end
        % Bit error calculation (2 bits per symbol)
        bits_tx = de2bi(s_idx-1, 2, 'left-msb');
        bits_rx = de2bi(s_hat_idx-1, 2, 'left-msb');
        bit_errors = sum(sum(bits_tx ~= bits_rx));
        total_bit_errors = total_bit_errors + bit_errors;
        total_bits = total_bits + N*2;
    end
    BER(idx) = total_bit_errors / total_bits;
end

% Plot BER vs SNR_dB
semilogy(SNR_dB, BER, 'o-');
xlabel('SNR (dB)');
ylabel('BER');
grid on;
title('4-QAM BER vs SNR (block fading)');
